---
title: 你不知道的JavaScript(上)阅读笔记
date: 2022-03-14 09:36:52
permalink: /pages/255fad/
categories:
  - 前端
tags:
  - JavaScript
---

### 作用域是什么

**JavaScript 编译过程**

在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编 译”。

- 分词/词法分析(Tokenizing/Lexing)
- 解析/语法分析(Parsing)
- 生成机器能执行的机器指令代码

编译过程中，JavaScript 引擎不会有大量的(像其他语言编译器那么多的)时间用来进行优化，因为与其他语言不同，**JavaScript 的编译过程不是发生在构建之前的**。

简单地说，**任何 JavaScript 代码片段在执行前都要进行编译(通常就在执行前)**。因此， JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且 通常马上就会执行它。

**理解作用域**

先介绍将要参与到对程序 var a = 2; 进行处理的过程中的角色

**引擎**
从头到尾负责整个 JavaScript 程序的编译及执行过程。

**编译器**
引擎的好朋友之一，负责语法分析及代码生成等脏活累活。

**作用域引擎**
的另一位好朋友，负责收集并维护由所有声明的标识符(变量)组成的一系列查 询，并实施一套非常严格的规则，**确定当前执行的代码对这些标识符的访问权限**。

下面我们将 var a = 2; 分解，看看引擎和它的朋友们是如何协同工作的。

编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。但是当编 译器开始进行代码生成时，它对这段程序的处理方式会和预期的有所不同。

可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括:“为一个变量分配内 存，将其命名为 a，然后将值 2 保存进这个变量。”然而，这并不完全正确。

事实上编译器会进行如下处理。

1. 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的 集合中。如果是，编译器会忽略该声明，继续进行编译;否则它会要求作用域在当前作 用域的集合中声明一个新的变量，并命名为 a。

2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值 操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的 变量。如果是，引擎就会使用这个变量;如果否，引擎会继续查找该变量（向上查找)。

总结: 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量(如 果之前没有声明过)，然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对 它赋值。

#### LHS 与 RHS

“L”和“R”分别代表左侧和右侧。 是一个赋值操作的左侧和右侧。

换句话说，当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。讲得更准确一点，**RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图 找到变量的容器本身，从而可以对其赋值。**

考虑下面的程序，其中既有 LHS 也有 RHS 引用:

```JavaScript
function foo(a) { console.log( a ); // 2
}
foo( 2 );
```

最后一行 foo(..) 函数的调用需要对 foo 进行 RHS 引用，意味着“去找到 foo 的值，并把 它给我”。并且 (..) 意味着 foo 的值需要被执行，因此它最好真的是一个函数类型的值!
这里还有一个容易被忽略却非常重要的细节。

代码中隐式的 a=2 操作可能很容易被你忽略掉。这个操作发生在 2 被当作参数传递给 foo(..) 函数时，2 会被分配给参数 a。**为了给参数 a(函数参数传递-隐式地)分配值**，需要进行一次 LHS 查询。

这里还有对 a 进行的 RHS 引用，并且将得到的值传给了 console.log(..)。console. log(..) 本身也需要一个引用才能执行，因此会对 console 对象进行 RHS 查询，并且检查 得到的值中是否有一个叫作 log 的方法。

#### 作用域嵌套

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，**在当前作用 域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域(也就是全局作用域)为止。**

![](https://qiniu.espe.work/blog/20220316100656.png)

函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。

但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块(通常指 { .. } 内部)。

try/catch 结构在 catch 分句中具有块作用域。

### 函数提升与变量提升

考虑以下代码:

```js
foo() // 1
var foo
function foo() {
  console.log(1)
}
foo = function() {
  console.log(2)
}
```

会输出 1 而不是 2 !这个代码片段会被引擎理解为如下形式:

```js
function foo() {
  console.log(1)
}
foo() // 1
foo = function() {
  console.log(2)
}
```

函数声明和变量声明都会被提升。但是一个值得注意的细节(这个细节可以出现在有多个“重复”声明的代码中)是**函数会首先被提升，然后才是变量**。

要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候，否则会引起很多危险的问题!

### 闭包

```js
function wait(message) {
  setTimeout(function timer() {
    console.log(message)
  }, 1000)
}
wait('Hello, closure!')
```

将一个内部函数(名为 timer)传递给 setTimeout(..)。timer 具有涵盖 wait(..) 作用域的闭包，因此还保有对变量 message 的引用。

wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失，timer 函数依然保有 wait(..)作用域的闭包。

深入到引擎的内部原理中，内置的工具函数 setTimeout(..) 持有对一个参数的引用，这个 参数也许叫作 fn 或者 func，或者其他类似的名字。引擎会调用这个函数，在例子中就是 内部的 timer 函数，而词法作用域在这个过程中保持完整。

这就是闭包。

#### 闭包实现现代的模块机制

大多数模块依赖加载器 / 管理器本质上都是将这种模块定义封装进一个友好的 API。这里并不会研究某个具体的库，为了宏观了解我会简单地介绍一些核心概念:

```js
var MyModules = (function Manager() {
  var modules = {}
  function define(name, deps, impl) {
    for (var i = 0; i < deps.length; i++) {
      deps[i] = modules[deps[i]]
    }
    modules[name] = impl.apply(impl, deps)
  }
  function get(name) {
    return modules[name]
  }

  return {
    define: define,
    get: get
  }
})()
```

这段代码的核心是 modules[name] = impl.apply(impl, deps)。为了模块的定义引入了包装 函数(可以传入任何依赖)，并且将返回值，也就是模块的 API，储存在一个根据名字来管理的模块列表中。

下面展示了如何使用它来定义模块:

```js
MyModules.define('bar', [], function() {
  function hello(who) {
    return 'Let me introduce: ' + who
  }
  return {
    hello: hello
  }
})
MyModules.define('foo', ['bar'], function(bar) {
  var hungry = 'hippo'
  function awesome() {
    console.log(bar.hello(hungry).toUpperCase())
  }
  return {
    awesome: awesome
  }
})
var bar = MyModules.get('bar')
var foo = MyModules.get('foo')
console.log(bar.hello('hippo')) // Let me introduce: hippo foo.awesome(); // LET ME INTRODUCE: HIPPO
```

"foo" 和 "bar" 模块都是通过一个返回公共 API 的函数来定义的。"foo" 甚至接受 "bar" 的 示例作为依赖参数，并能相应地使用它。

模块管理器没有任何特殊的“魔力”。它们符合前面列出的模块模式的两个 特点:为函数定义引入包装函数，并保证它的返回值和模块的 API 保持一致。换句话说，模块就是模块，即使在它们外层加上一个友好的包装工具也不会发生任何变化。

ES6 中为模块增加了一级语法支持。但通过模块系统进行加载时，ES6 会将文件当作独立 的模块来处理。每个模块都可以导入其他模块或特定的 API 成员，同样也可以导出自己的 API 成员。

模块文件中的内容会被当作好像包含在作用域闭包中一样来处理，就和前面介绍的函数闭 包模块一样。

### this 到底是什么

```js
function foo() {
  var a = 2
  this.bar()
}
function bar() {
  console.log(this.a)
}
foo() // ReferenceError: a is not defined
```

每当你想要把 this 和词法作用域的查找混合使用时，一定要提醒自己，这是无法实现的。

之前我们说过 this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调 用时的各种条件。**this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式**。
当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包 含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this 就是记录的 其中一个属性，会在函数执行的过程中用到。

在理解 this 的绑定过程之前，首先要理解调用位置:调用位置就是函数在代码中被调用的 位置(而不是声明的位置)。只有仔细分析调用位置才能回答这个问题:这个 this 到底引 用的是什么?

通常来说，寻找调用位置就是寻找“函数被调用的位置”，但是做起来并没有这么简单， 因为某些编程模式可能会隐藏真正的调用位置。

最重要的是要分析调用栈(就是为了到达当前执行位置所调用的所有函数)。我们关心的 调用位置就在当前正在执行的函数的前一个调用中。

下面我们来看看到底什么是调用栈和调用位置:

```js
function baz() {
  // 当前调用栈是:baz
  // 因此，当前调用位置是全局作用域
  console.log('baz')
}
bar() // bar 的调用位置
function bar() {
  82
  // 当前调用栈是 baz -> bar
  // 因此，当前调用位置在 baz 中
  console.log('bar')
}
foo() // <-- foo 的调用位置 }
function foo() {
  // 当前调用栈是 baz -> bar -> foo // 因此，当前调用位置在 bar 中
  console.log('foo')
}
baz() // <-- baz 的调用位置
```

回调函数当作参数传入：

```js
function foo() {
  console.log(this.a)
}
function doFoo(fn) {
  // fn 其实引用的是 foo fn(); // <-- 调用位置!
}
var obj = { a: 2, foo: foo }
var a = 'oops, global' // a 是全局对象的属性 doFoo( obj.foo ); // "oops, global"
```

参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一 个例子一样。

就像我们看到的那样，回调函数丢失 this 绑定是非常常见的

如果你经常编写 this 风格的代码，但是绝大部分时候都会使用 self = this 或者箭头函数 来否定 this 机制，那你或许应当:

1. 只使用词法作用域并完全抛弃错误 this 风格的代码;
2. 完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self = this 和箭头函数。

当然，包含这两种代码风格的程序可以正常运行，但是在同一个函数或者同一个程序中混 合使用这两种风格通常会使代码更难维护，并且可能也会更难编写。

### 对象

JS 一 共 有 六 种 主 要 类 型 ( 术 语 是 “ 语 言 类 型 ”) :

• string
• number
• boolean
• null
• undefined
• object

注意，简单基本类型(string、boolean、number、null 和 undefined)本身并不是对象。 **null 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 null 执行 typeof null 时会返回字符串 "object"。1 实际上，null 本身是基本类型。**

原始值 "I am a string" 并不是一个对象，它只是一个字面量，并且是一个不可变的值。**如果要在这个字面量上执行一些操作，比如获取长度、访问其中某个字符等，那需要将其 转换为 String 对象**。

有一种常见的错误说法是“JavaScript 中万物皆是对象”，这显然是错误的。

实际上，JavaScript 中有许多特殊的对象子类型，我们可以称之为复杂基本类型。

函数就是对象的一个子类型(从技术角度来说就是“可调用的对象”)。**JavaScript 中的函 数是“一等公民”，因为它们本质上和普通的对象一样(只是可以调用)，所以可以像操作 其他对象一样操作函数(比如当作另一个函数的参数)。**

数组也是对象的一种类型，具备一些额外的行为。数组中内容的组织方式比一般的对象要 稍微复杂一些。

#### 内置对象

JavaScript 中还有一些对象子类型，通常被称为内置对象。

• String
• Number
• Boolean
• Object
• Function
• Array
• Date
• RegExp
• Error

这些内置对象从表现形式来说很像其他语言中的类型(type)或者类(class)，比如 Java 中的 String 类。

幸好，在必要时语言会自动把字符串字面量转换成一个 String 对象，也就是说你并不需要 显式创建一个对象。JavaScript 社区中的大多数人都认为能使用文字形式时就不要使用构造形式。
思考下面的代码:

```js
var strPrimitive = 'I am a string'
console.log(strPrimitive.length) // 13
console.log(strPrimitive.charAt(3)) // "m"
```

使用以上两种方法，我们都可以直接在字符串字面量上访问属性或者方法，之所以可以这 样做，是因为引擎自动把字面量转换成 String 对象，所以可以访问属性和方法。

#### 属性名永远都是字符串

在对象中，属性名永远都是字符串。如果你使用 string(字面量)以外的其他值作为属性 名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的 确是数字，但是在对象属性名中数字会被转换成字符串，所以当心不要搞混对象和数组中 数字的用法:

```js
var myObject = {}
myObject[true] = 'foo'
myObject[3] = 'bar'
myObject[myObject] = 'baz'
myObject['true'] // "foo"
myObject['3'] // "bar"
myObject['[object Object]'] // "baz"
```

#### 属性与方法

如果访问的对象属性是一个函数，有些开发者喜欢使用不一样的叫法以作区分。由于函数 很容易被认为是属于某个对象，在其他语言中，属于对象(也被称为“类”)的函数通常 被称为“方法”，因此把“属性访问”说成是“方法访问”也就不奇怪了。

从技术角度来说，函数永远不会“属于”一个对象，所以把对象内部引用的函数称为“方法”似乎有点不妥。

确实，有些函数具有 this 引用，有时候这些 this 确实会指向调用位置的对象引用。**但是 这种用法从本质上来说并没有把一个函数变成一个“方法”**，因为 this 是在运行时根据调 用位置动态绑定的，所以函数和对象的关系最多也只能说是间接关系。

举例来说:

```js
function foo() {
  console.log('foo')
}
var someFoo = foo // 对 foo 的变量引用
var myObject = { someFoo: foo }
foo // function foo(){..}
someFoo // function foo(){..}
myObject.someFoo // function foo(){..}
```

someFoo 和 myObject.someFoo 只是对于同一个函数的不同引用，并不能说明这个函数是特 别的或者“属于”某个对象。如果 foo() 定义时在内部有一个 this 引用，那这两个函数引
对象, 用的唯一区别就是 myObject.someFoo 中的 this 会被隐式绑定到一个对象。无论哪种引用 形式都不能称之为“方法”。

**最保险的说法可能是，“函数”和“方法”在 JavaScript 中是可以互换的。**

#### 数组对象

数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性:

```js
var myArray = ['foo', 42, 'bar']
myArray.baz = 'baz'
myArray.length // 3
myArray.baz // "baz"
```

可以看到虽然添加了命名属性(无论是通过 . 语法还是 [] 语法)，**数组的 length 值并未发 生变化。**

注意:如果你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成 一个数值下标(因此会修改数组的内容而不是添加一个属性):

```js
var myArray = ['foo', 42, 'bar']
myArray['3'] = 'baz'
myArray.length // 4
myArray[3] // "baz"
```

#### setter 和 getter

在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法 应用在整个对象上。getter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏 函数，会在设置属性值时调用

当你给一个属性定义 getter、setter 或者两者都有时，这个属性会被定义为“访问描述 符”(和“数据描述符”相对)。对于访问描述符来说，JavaScript 会忽略它们的 value 和 writable 特性，取而代之的是关心 set 和 get(还有 configurable 和 enumerable)特性。

思考下面的代码:

```js
var myObject = {
  // 给 a 定义一个 getter
  get a() {
    return 2
  }
}
Object.defineProperty(
  myObject, // 目标对象
  'b', // 属性名
  {
    // 描述符
    // 给 b 设置一个 getter
    get: function() {
      return this.a * 2
    },
    // 确保 b 会出现在对象的属性列表中
    enumerable: true
  }
)

myObject.a // 2
myObject.b // 4
```

#### 存在性

前面我们介绍过，如 myObject.a 的属性访问返回值可能是 undefined，但是这个值有可能 是属性中存储的 undefined，也可能是因为属性不存在所以返回 undefined。那么如何区分 这两种情况呢?
我们可以在不访问属性值的情况下判断对象中是否存在这个属性:

```js
var myObject = { a: 2 }
'a' in myObject // true
'b' in myObject // false
myObject.hasOwnProperty('a') // true
myObject.hasOwnProperty('b') // false
```

**in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链。相比之下， hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链**。 




### 原型


Object.prototype 但是到哪里是 [[Prototype]] 的“尽头”呢? 所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype。由于所有的“普通” (内置，不是特定主机的扩展)对象都“源于”(或者说把 [[Prototype]] 链的顶端设置为)这个 Object.prototype 对象

**所以它包含 JavaScript 中许多通用的功能。 有些功能你应该已经很熟悉了，比如说 .toString() 和 .valueOf() .hasOwnProperty(..)  .isPrototypeOf(..)**。