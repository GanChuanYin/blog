---
title: 常见算法类型
date: 2022-05-16 15:31:43
permalink: /pages/a527d1/
categories:
  - 算法与数据结构
tags:
  - 
---
大部分的算法都可以归为以下几个基础类型

### 一、贪心算法（Greedy Algorithm)

贪婪算法，是一种在每一步选择中都采取在 <font color=#3498db>当前状态下最好或最优（即最有利）的选择</font> ，从而希望导致结果是最好或最优的算法。

贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是 <font color=#3498db>局部最优解能决定全局最优解，</font> 。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。

贪心法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码……对于其他问题，贪心法一般不能得到我们所要求的答案。<font color=#3498db>一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法</font>。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。

### 二、回溯法（back tracking）

回溯法（back tracking）（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。<font color=#3498db>但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择</font> ，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

> 回溯法可以理解为通过选择不同的岔路口寻找目的地，一个岔路口一个岔路口的去尝试找到目的地。如果走错了路，继续返回来找到岔路口的另一条路，直到找到目的地。

经典例子：八皇后问题

八皇后问题是一个古老而著名的问题，是回溯算法的典型例题。该问题是十九世纪著名的数学家高斯 1850 年提出：在 8X8 格的国际象棋上摆放八个皇后（棋子），使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上。

![](https://qiniu.espe.work/blog/20220516154336.png)

![](https://qiniu.espe.work/blog/U.png)

> 参考 https://zhuanlan.zhihu.com/p/54275352

### 三、动态规划（Dynamic Programming） 简称 DP

动态规划通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 <font color=#3498db>动态规划常常适用于有重叠子问题和最优子结构性质的问题</font>，动态规划方法所耗时间往往远少于朴素解法。

动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。

通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指數增長时特别有用

#### 适用情况

1. 最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态規劃算法解决问题提供了重要线索。

2. 无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。

3. 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态規劃算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。

例子: DAG 最短路

![](https://qiniu.espe.work/blog/20220516160013.png)

这个问题能用 DP 解决吗？我们先试着记从 S 到 P 的最少费用为 f(P).　　想要到 T，要么经过 C，要么经过 D。从而

![](https://qiniu.espe.work/blog/equation.svg)

好像看起来可以 DP。现在我们检验刚刚那两个性质：

- 无后效性：对于点 P，一旦 f(P)确定，以后就只关心 f(P)的值，不关心怎么去的。
- 最优子结构：对于 P，我们当然只关心到 P 的最小费用，即 f(P)。如果我们从 S 走到 T 是 ，那肯定 S 走到 Q 的最优路径是

![](https://qiniu.espe.work/blog/equation-1.svg)

对一条最优的路径而言，从 S 走到沿途上所有的点（子问题）的最优路径，都是这条大路的一部分。这个问题的最优子结构性质是显然的。　　既然这两个性质都满足，那么本题可以 DP。式子明显为：
![](https://qiniu.espe.work/blog/equation-2.svg)

其中 R 为有路通到 P 的所有的点，为 R 到 P 的过路费。代码实现也很简单，拓扑排序即可。

#### 对 DP 原理的一点讨论

**核心思想**

DP 为什么会快？ 无论是 DP 还是暴力，我们的算法都是在可能解空间内，寻找最优解。

来看钞票问题。暴力做法是枚举所有的可能解，这是最大的可能解空间。DP 是枚举有希望成为答案的解。这个空间比暴力的小得多。也就是说：<font color=#3498db>DP 自带剪枝</font>。

DP 舍弃了一大堆不可能成为最优解的答案。譬如：15 = 5+5+5 被考虑了。　 15 = 5+5+1+1+1+1+1 从来没有考虑过，因为这不可能成为最优解。

从而我们可以得到 DP 的核心思想：尽量缩小可能解空间。 在暴力算法中，可能解空间往往是指数级的大小；如果我们采用 DP，那么有可能把解空间的大小降到多项式级。一般来说，解空间越小，寻找解就越快。这样就完成了优化。

**DP 的操作过程**

一言以蔽之：大事化小，小事化了。将一个大问题转化成几个小问题；求解小问题； 推出大问题的解。

**如何设计 DP 算法**

下面介绍比较通用的设计 DP 算法的步骤。

1. 首先，把我们面对的局面表示为 x。这一步称为 <font color=#3498db>设计状态</font> 。
2. 对于状态 x，记我们要求出的答案(e.g. 最小费用)为 f(x).我们的目标是求出 f(T).
3. 找出 f(x)与哪些局面有关（记为 p），写出一个式子（称为 <font color=#3498db>状态转移方程</font> ），通过 f(p)来推出 f(x).

设计 DP 算法，往往可以遵循 DP 三连：

1. 我是谁？ ——设计状态，表示局面
2. 我从哪里来？
3. 我要到哪里去？ ——设计转移

> 参考 https://www.zhihu.com/question/23995189

### 四、分治法 Divide and conquer

分治法可以通俗的解释为：把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解

分治法的精髓：

1. 分--将问题 <font color=#3498db>分解</font> 为规模更小的子问题；
2. 治--将这些规模更小的子问题 <font color=#3498db>逐个击破</font> ；
3. 合--将已解决的子问题 <font color=#3498db>合并</font> ，最终得出“母”问题的解；

分治法就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……

例子： 汉诺塔问题

如下图所示，从左到右有 A、B、C 三根柱子，其中 A 柱子上面有从小叠到大的 n 个圆盘，现要求将 A 柱子上的圆盘移到 C 柱子上去，期间只有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数。

![](https://qiniu.espe.work/blog/20220516161727.png)

思路分析：

![](https://qiniu.espe.work/blog/20220516162036.png)

考虑最简单情况 n=2，三根柱子分别为 A、B、C，此时，在 A 上有 2 片金片(假设从小到大依次为 1,2)。那么我们的解决步骤可以归结为如下：

1，先把 A 上 1 号金片移至 B。

2，再把 A 上 2 号金片移至 C。

3，再把 B 上 1 号金片移至 C。 考虑 n 增大的情况： 1，先把 A 上从 1 到 n-1 号金片移至 B。

2，再把 A 上 64 号金片移至 C。

3，再把 B 上从 1 到 n-1 号金片移至 C。

可以看到递归的影子，要解决 n 个，先解决 n-1 个，可以分治为 n=2 的最简单情况并加以解决。
