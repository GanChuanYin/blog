---
title: JS实现常见排序
date: 2022-03-26 22:41:35
permalink: /pages/be2e32/
categories:
  - 算法与数据结构
tags:
  - 算法
---

JS 实现常见排序算法

![](https://qiniu.espe.work/blog/20220327171807.png)

### 工具

生成测试数据

```JS

function generateTestArr(num) {
  const arr = []
  for (let index = 0; index < num; index++) {
    arr.push(Math.round(Math.random() * num))
  }
  return arr
}

```

在下面的测试算法例子中 都是用的 1w 个数字组成的数组，数字范围为 0-1w

**计算排序算法运行时间**

```JS
function getProcessTime(algoFunc, arr) {
  console.time('排序耗时')
  const res = algoFunc(arr)
  console.timeEnd('排序耗时')
  return res
}
```

### 冒泡排序（Bubble Sort）

```JS

function bubbleSort(arr) {
  if (arr.length < 2) return arr
  const len = arr.length
  for (let index = 0; index < len; index++) {
    for (let i = 0; i < len - index - 1; i++) {
      if (arr[i] > arr[i + 1]) {
        const temp = arr[i]
        arr[i] = arr[i + 1]
        arr[i + 1] = temp
        // ;[arr[i], arr[i + 1]] = [arr[i + 1], arr[i]]
      }
    }
  }
  return arr
}

console.log(bubbleSort([1, 4, 3, 2, 12, 5])) // [ 12,  5, 4, 3,  2,  1]
```

### 选择排序（Selection Sort）

```JS
function selectionSort(arr) {
  const len = arr.length
  for (let index = 0; index < len; index++) {
    let maxIndex = index
    for (let i = index + 1; i < len; i++) {
      if (arr[i] > arr[maxIndex]) {
        const temp = arr[i]
        arr[i] = arr[maxIndex]
        arr[maxIndex] = temp
      }
    }
  }
  return arr
}

console.log(selectionSort([22,-1,19,1, 4, 3, 2, 12, 5])) //[ 22, 19, 12,  5, 4, 3,  2,  1, -1]
```

### 插入排序（Insertion Sort）

### 归并排序

主要采用分而治之的思想

```js
function merge(arr1, arr2) {
  var result = []
  while (arr1.length > 0 && arr2.length > 0) {
    if (arr1[0] > arr2[0]) {
      /*shift()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。*/
      result.push(arr1.shift())
    } else {
      result.push(arr2.shift())
    }
  }
  return result.concat(arr1).concat(arr2)
}

function mergeSort(arr) {
  let len = arr.length
  if (len < 2) {
    return arr
  }
  let middle = Math.floor(len / 2),
    left = arr.slice(0, middle),
    right = arr.slice(middle)
  return merge(mergeSort(left), mergeSort(right))
}

```


### 插入排序（Insertion Sort）

