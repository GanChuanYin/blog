---
title: Axiosæºç åˆ†æ
date: 2021-03-25 18:14:46
permalink: /pages/954714/
meta:
  - name: keywords
  - content: Axios,Axiosæºç ,axiosè¯¦è§£
categories:
  - ç¬”è®°
tags:
  -
---

# Axios æºç åˆ†æ

ä»å°è£…è‡ªå·±çš„ Ajaxï¼Œå†åˆ° axios æºç ã€‚
æ€»ä½“æ¥è¯´ï¼Œaxios åœ¨é…ç½®é¡¹ä¸Šåšäº†å¾ˆå¤š
æˆ‘ä»¬èƒ½å­¦ä¹ çš„åœ°æ–¹ä¸ä»…ä»…åœ¨äºå¦‚ä½•å°è£…ï¼ŒåŒç­‰é‡è¦çš„è¿˜æœ‰å®ƒå®ç°çš„æŠ€å·§

<!-- more -->

## XMLHttpRequest ç®€å•ä½¿ç”¨

### ä»‹ç»

- å®ä¾‹

```js
let xhr = new XMLHttpRequest()
```

- å‘èµ· http è¯·æ±‚

```js
xhr.open('GET', '/api/data')
xhr.send()
```

- è®¾ç½®å›è°ƒå‡½æ•°

```js
xhr.onreadystatechange = function() {
  // readyState: xhr å¯¹è±¡çš„çŠ¶æ€
  // statusï¼šxhr å“åº”çš„çŠ¶æ€
  if (xhr.readyState == 4 && xhr.status == 200) {
    alert(xhr.responseText)
  } else {
    alert(xhr.statusText)
  }
}
```

### å°è£… Ajax

å°è£…è‡ªå·±çš„ Ajax

```js
  const fn = (res) => { }
  let { method = 'GET', url, data, onSuccess = fn, onError = fn, type = '' } = options || {}
  // åˆ›å»ºå…¼å®¹ XMLHttpRequest å¯¹è±¡
  let xhr
  if (window.XMLHttpRequest) {
    xhr = new XMLHttpRequest()
  } else {
    xhr = new ActiveXObject('Microsoft.XMLHTTP')
  }

  // ç»™è¯·æ±‚æ·»åŠ çŠ¶æ€å˜åŒ–äº‹ä»¶å¤„ç†å‡½æ•°
  xhr.onreadystatechange = function () {
    // åˆ¤æ–­çŠ¶æ€ç 
    if (xhr.readyState == 4) {
      if (xhr.status == 200) {
        let res
        // æ ¹æ®typeå‚æ•°ï¼Œåˆ¤æ–­è¿”å›çš„å†…å®¹éœ€è¦è¿›è¡Œæ€æ ·çš„å¤„ç†
        if (type == 'json') {
          // è·å¾— json å½¢å¼çš„å“åº”æ•°æ®ï¼Œå¹¶ä½¿ç”¨parseæ–¹æ³•è§£æ
          res = JSON.parse(xhr.responseText)
        } else if (type == 'xml') {
          // è·å¾— XML å½¢å¼çš„å“åº”æ•°æ®
          res = xhr.responseXML
        } else {
          // è·å¾—å­—ç¬¦ä¸²å½¢å¼çš„å“åº”æ•°æ®
          res = xhr.responseText
        }
        onSuccess(res) // æˆåŠŸå›è°ƒ
      } else {
        onError(xhr.responseText)
      }
    }
  }

  // åˆ¤æ–­dataæ˜¯å¦æœ‰æ•°æ®
  let param = ''
  if (data) {
    if (JSON.stringify(data) != '{}') { // è¿™é‡Œä½¿ç”¨stringifyæ–¹æ³•å°†jså¯¹è±¡æ ¼å¼åŒ–ä¸ºjsonå­—ç¬¦ä¸²
      url += '?'
      for (let i in data) {
        param += i + '=' + data[i] + '&'   // å°†jså¯¹è±¡é‡ç»„ï¼Œæ‹¼æ¥æˆurlå‚æ•°å­˜å…¥paramå˜é‡ä¸­
      }
      // å»é™¤æ‹¼æ¥çš„æœ€åä¸€ä¸ª&å­—ç¬¦
      param = param.slice(0, param.length - 1)
    }
  }


  // åˆ¤æ–­methodæ˜¯å¦ä¸ºget
  if (method == 'get') {
    // æ˜¯åˆ™å°†æ•°æ®æ‹¼æ¥åœ¨urlåé¢
    url = url + param
  }


  // åˆå§‹åŒ–è¯·æ±‚
  xhr.open(method, url, true)

  // å¦‚æœmethod == post
  if (method == 'post') {
    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
    //å‘é€è¯·æ±‚
    xhr.send(param)
  } else {
    // å‘é€è¯·æ±‚
    xhr.send(null)
  }
}
```

éªŒè¯

```js
myAjax({
  method: 'get',
  url: 'https://coderly.cn/',
  type: '',
  onSuccess(result) {
    console.log('result', result)
  },
  onError(error) {
    console.log('error', error)
  },
})
```

<img src="https://raw.githubusercontent.com/coderlyu/au-blog/master/docs/.vuepress/public/images/blogs/axios-1.png" alt="Axios-å°è£…ajaxæ•ˆæœå›¾ç‰‡">

## Node çš„ http æ¨¡å— ä½¿ç”¨

```js
const http = require('http')
http
  .request(
    {
      url: 'http://192.168.1.2/index.html',
      method: 'GET',
    },
    (response) => {
      let result = ''

      response.on('data', (chunk) => {
        result += chunk
      })

      response.on('end', () => {
        console.log('Success:', result)
      })
    }
  )
  .on('error', (error) => {
    console.log('Error:' + error.message)
  })
```

## Axios

> ç‰ˆæœ¬ï¼šv0.20.0

### ç›®å½•ç»“æ„

```
|- examples
|- lib
  |- adapters # çœŸå®å‘èµ·è¯·æ±‚çš„(nodeçš„httpæ¨¡å—å’ŒXMLHttpRequeståšå…¼å®¹nodeç¯å¢ƒå’Œæµè§ˆå™¨ç¯å¢ƒ)
    |- http.js
    |- xhr.js
  |- cancel # å–æ¶ˆè¯·æ±‚çš„æ“ä½œ
  |- core # axios æ ¸å¿ƒåŠŸèƒ½
    |- Axios.js # Axios æ„é€ å‡½æ•°
    |- buildFullPath.js
    |- createError.js
    |- dispatchRequest.js # request() å®é™…å‘èµ·è¯·æ±‚çš„å‡½æ•°(æ˜¯adapterså…¼å®¹æ€§å¤„ç†)
    |- enhanceError.js
    |- InterceptorManager.js
    |- mergeConfig.js # config é…ç½®é¡¹åˆå¹¶å‡½æ•°
    |- settle.js
    |- transformData.js
  |- helpers # è¾…åŠ©å·¥å…·ï¼Œä¸€èˆ¬å’Œè§£æã€urlã€cookieç­‰æœ‰å…³
  |- axios.js # å¯¼å‡º axios å¯¹è±¡ä»¥åŠåœ¨è¯¥å¯¹è±¡ä¸Šæ·»åŠ é¢å¤–æ–¹æ³•
  |- defaults.js # axios å†…éƒ¨é»˜è®¤é…ç½®
  |- utils.js # å¸¸ç”¨è½¬æ¢(åˆ¤æ–­)å·¥å…·
|- sandbox
|- index.js # ä»…å¯¼å‡ºæ–‡ä»¶
|- package.json
|- webpack.config.js
```

### axios.js

> éæ„é€ å‡½æ•°
> è´Ÿè´£åˆ›å»ºå®ä¾‹é¢å¤–æ·»åŠ æ–¹æ³•å¹¶å¯¼å‡º

```js
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig) // åˆ›å»ºå®ä¾‹
  var instance = bind(Axios.prototype.request, context) // bind è¿”å›ä¸€ä¸ªå‡½æ•°ï¼Œç›´æ¥æ‰§è¡Œ instance å‡½æ•°å°†ä¼šä»£ç†åˆ° Axios åŸå‹ä¸Šçš„ request æ–¹æ³•ä¸Š ä¾‹å¦‚ï¼šaxios() -> è°ƒç”¨çš„æ˜¯ Axios.prototype.request()

  utils.extend(instance, Axios.prototype, context) // å°† axios.prototype ä¸Šå±æ€§å’Œæ–¹æ³• å¤åˆ¶åˆ° instance å‡½æ•°ä¸Š å¹¶å°† this æŒ‡å‘ context å¯¹è±¡

  utils.extend(instance, context) // å°† context ä¸Šå±æ€§å’Œæ–¹æ³• å¤åˆ¶åˆ° instance å‡½æ•°ä¸Š

  return instance
}

var axios = createInstance(defaults) // è°ƒç”¨åˆ›å»ºå®ä¾‹å‡½æ•°

axios.Axios = Axios // å…¬å¼€Axiosç±»ä»¥å…è®¸ç±»ç»§æ‰¿

axios.create = function create(instanceConfig) {
  // å·¥å‚å‡½æ•°ï¼Œè¿”å›ä¸€ä¸ªæ–°å¯¹è±¡ï¼Œå¸¸ç”¨åœ¨
  return createInstance(mergeConfig(axios.defaults, instanceConfig))
}

// æ·»åŠ åˆ›å»ºå–æ¶ˆè¯·æ±‚çš„å‡½æ•°
axios.Cancel = require('./cancel/Cancel')
axios.CancelToken = require('./cancel/CancelToken')
axios.isCancel = require('./cancel/isCancel')

axios.all = function all(promises) {
  // axios.all è°ƒç”¨çš„æ˜¯ Promise.all
  return Promise.all(promises)
}
axios.spread = require('./helpers/spread') // å‡½æ•°æŸ¯é‡ŒåŒ–

module.exports = axios

module.exports.default = axios // å…è®¸åœ¨TypeScriptä¸­ä½¿ç”¨é»˜è®¤å¯¼å…¥è¯­æ³•
```

### core

#### Axios.js

> Axios æ„é€ å‡½æ•°

- this.interceptors.request(response).use è¯´æ˜

```js
function InterceptorManager() {
  this.handlers = []
}
// è°ƒç”¨useï¼Œç›¸å½“äºå¾€æ•°ç»„ä¸­æ”¾å…¥äº†ä¸€ä¸ªå¯¹è±¡(fulfilled, rejected)
// è¯·æ±‚æ‹¦æˆªå™¨ï¼š
// axioså–æ•°æ®æ—¶ï¼Œä»ç¬¬ä¸€ä¸ªå¾€åéå†ï¼Œæ’å…¥åˆ° chain é“¾çš„å‰é¢
// æ‰€ä»¥æœ€åæ‰§è¡Œé¡ºåºæ˜¯ï¼šåè°ƒç”¨ use çš„ å…ˆæ‰§è¡Œ

// å“åº”æ‹¦æˆªå™¨ï¼š
// axioså–æ•°æ®æ—¶ï¼Œä»ç¬¬ä¸€ä¸ªå¾€åéå†ï¼Œæ’å…¥åˆ° chain é“¾çš„åé¢
// æ‰€ä»¥æœ€åæ‰§è¡Œé¡ºåºæ˜¯ï¼šå…ˆè°ƒç”¨ use çš„ å…ˆæ‰§è¡Œ
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
  })
  return this.handlers.length - 1
}

InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null
  }
}

InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h)
    }
  })
}
```

ç”¨ä¸€å¼ å›¾è¡¨ç¤ºå¦‚ä¸‹

<img src="https://raw.githubusercontent.com/coderlyu/au-blog/master/docs/.vuepress/public/images/blogs/axios-2.png" alt="Axios æ‹¦æˆªå™¨å›¾ç‰‡">

- Axios æ„é€ å‡½æ•°

* ç»™æ„é€ å‡½æ•°åŸå‹æ·»åŠ å„ç§æ–¹æ³•
* é€šè¿‡ chain æ•°ç»„ï¼Œæ§åˆ¶æ‰§è¡Œé¡ºåº(å¯¹è¯·æ±‚å‰ï¼Œå“åº”ååšä¸€äº›å¤„ç†)
* æœ€ç»ˆæ‰€æœ‰ç±»å‹æ–¹æ³•è¯·æ±‚éƒ½æ˜¯åœ¨è°ƒç”¨ `request` æ–¹æ³•

```js
function Axios(instanceConfig) {
  // Axios æ„é€ å‡½æ•°
  this.defaults = instanceConfig
  this.interceptors = {
    // æ‹¦æˆªå™¨
    request: new InterceptorManager(),
    response: new InterceptorManager(),
  }
}

Axios.prototype.request = function request(config) {
  // å‘èµ·è¯·æ±‚æœ€é‡è¦çš„æ–¹æ³•(æœ€åå„ç±»è¯·æ±‚éƒ½ä¼šè°ƒç”¨è¯¥æ–¹æ³•)
  if (typeof config === 'string') {
    config = arguments[1] || {}
    config.url = arguments[0]
  } else {
    config = config || {}
  }

  config = mergeConfig(this.defaults, config) // åˆå¹¶é…ç½®

  // è®¾ç½® config.method
  if (config.method) {
    config.method = config.method.toLowerCase()
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase()
  } else {
    config.method = 'get'
  }

  // è¿æ¥æ‹¦æˆªå™¨ä¸­é—´ä»¶
  var chain = [dispatchRequest, undefined] // dispatchRequest ä¸ºçœŸå®å‘èµ·è¯·æ±‚çš„å‡½æ•°ï¼ŒdispatchRequest å‰ä¸ºè¯·æ±‚æ‹¦æˆªå™¨ï¼Œåæ˜¯å“åº”æ‹¦æˆªå™¨
  var promise = Promise.resolve(config) // å°† config å‚æ•°ä½œä¸ºå€¼ åœ¨ chain é“¾ä¸­ä¼ é€’(æ¯ä¸ªæ‹¦æˆªå™¨éƒ½å¿…é¡»å°†return config|Error)

  this.interceptors.request.forEach(function unshiftRequestInterceptors(
    interceptor
  ) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected) // æ·»åŠ è¯·æ±‚æ‹¦æˆªï¼Œ[fulfilled, rejected]
  })

  this.interceptors.response.forEach(function pushResponseInterceptors(
    interceptor
  ) {
    chain.push(interceptor.fulfilled, interceptor.rejected) // æ·»åŠ å“åº”æ‹¦æˆªï¼Œ[fulfilled, rejected]
  })

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift()) // æ¯æ¬¡å–å‡ºä¸¤ä¸ªç”¨ Promise å°† chain é“¾ä¸²è”èµ·æ¥ï¼Œ[resolve, reject]
  }

  return promise
}

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config)
  return buildURL(config.url, config.params, config.paramsSerializer).replace(
    /^\?/,
    ''
  )
}

// utils.forEach å…¶å®å°±æ˜¯ éå†çš„æ–¹æ³•ï¼Œ åœ¨Axios åŸå‹ä¸Šæ·»åŠ  delete, get, head, options æ–¹æ³•
utils.forEach(
  ['delete', 'get', 'head', 'options'],
  function forEachMethodNoData(method) {
    Axios.prototype[method] = function(url, config) {
      return this.request(
        // æœ€åè°ƒç”¨çš„æ˜¯ Axios.prototype.request æ–¹æ³• çœ‹ä¸Šâ†‘â†‘â†‘
        mergeConfig(config || {}, {
          method: method,
          url: url,
        })
      )
    }
  }
)
// åŒä¸Š
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  Axios.prototype[method] = function(url, data, config) {
    return this.request(
      mergeConfig(config || {}, {
        method: method,
        url: url,
        data: data,
      })
    )
  }
})

module.exports = Axios
```

#### dispatchRequest.js

> Axios å®ä¾‹å¯¹è±¡çš„ request æ–¹æ³•ä¸­ä¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°
> è¿™ä¸ªå‡½æ•°æ˜¯å®é™…å‘èµ·è¯·æ±‚çš„å‡½æ•°
> å…¼å®¹æµè§ˆå™¨å’Œ node ç¯å¢ƒ(æµè§ˆå™¨çš„ XMLHttpRequest å’Œ node çš„ http)

åŒæ—¶æ”¯æŒ node ç¯å¢ƒ å’Œæµè§ˆå™¨ç¯å¢ƒ

```js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested()
  }
}

module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config) // å¦‚æœæ­¤æ—¶ å·²ç»å–æ¶ˆäº†è¯·æ±‚ï¼Œç›´æ¥æŠ›å‡ºå¼‚å¸¸

  // Ensure headers exist
  config.headers = config.headers || {}

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest // transformRequest æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œç”±ç”¨æˆ·è‡ªå®šä¹‰è½¬æ¢ data æ•°æ®çš„ï¼Œå¹¶è¿”å›è½¬æ¢åçš„ dataï¼Œå¯çœ‹ğŸ‘‡ğŸ‘‡ğŸ‘‡
  )

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  )

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method]
    }
  )

  var adapter = config.adapter || defaults.adapter

  // å‘èµ·è¯·æ±‚
  return adapter(config).then(
    function onAdapterResolution(response) {
      throwIfCancellationRequested(config)

      // Transform response data
      response.data = transformData(
        response.data,
        response.headers,
        config.transformResponse // transformResponse æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œç”¨æˆ·è‡ªå®šä¹‰çš„å“åº”æ•°æ®è½¬æ¢ï¼Œçœ‹ğŸ‘†ğŸ‘†ğŸ‘†
      )

      return response // æˆåŠŸçš„å“åº”
    },
    function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config) // å¦‚æœæ­¤æ—¶å·²ç»å–æ¶ˆäº†è¯·æ±‚ï¼Œç›´æ¥æŠ›å‡ºå¼‚å¸¸

        // Transform response data
        if (reason && reason.response) {
          reason.response.data = transformData(
            reason.response.data,
            reason.response.headers,
            config.transformResponse // transformResponse æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œç”¨æˆ·è‡ªå®šä¹‰çš„å“åº”æ•°æ®è½¬æ¢ï¼Œçœ‹ğŸ‘†ğŸ‘†ğŸ‘†
          )
        }
      }

      return Promise.reject(reason)
    }
  )
}
```

### cancel

> å–æ¶ˆè¯·æ±‚çš„æ“ä½œ
> å®é™…ä¸Šæ˜¯è°ƒç”¨ http çš„ abortedï¼ˆXMLHttpRequest çš„ abortï¼‰æ–¹æ³•

#### Cancel.js

```js
// åœ¨å–æ¶ˆæ“ä½œæ—¶æŠ›å‡ºçš„å¯¹è±¡
function Cancel(message) {
  this.message = message
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '')
}

Cancel.prototype.__CANCEL__ = true // ç”¨æ¥åˆ¤æ–­æ˜¯å¦åŠ äº† å–æ¶ˆè¯·æ±‚çš„ é…ç½®

module.exports = Cancel
```

#### CancelToken.js

> é€šè¿‡ CancelToken åˆ›å»ºå¯¹è±¡ï¼Œå¹¶ä¼ å…¥ config é…ç½®ä¸­
> å›è°ƒå‡½æ•°ä¸­ä¼šå‘å¤–æš´éœ²ä¸€ä¸ªå¯ä»¥æ§åˆ¶ Promise çŠ¶æ€çš„å‡½æ•°

```js
// CancelToken æ„é€ å‡½æ•°ï¼Œç”¨äºè¯·æ±‚å–æ¶ˆæ“ä½œ
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.')
  }

  var resolvePromise // å­˜å‚¨æ§åˆ¶ Promse çŠ¶æ€ä¸ºæˆåŠŸ çš„å‡½æ•°ï¼Œ çœ‹ğŸ‘‡ğŸ‘‡ğŸ‘‡
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve
  })

  var token = this
  executor(function cancel(message) {
    // è¿™ä¸ªå‡½æ•°æ˜¯æ–°å»ºå¯¹è±¡æ—¶ä½œä¸ºå‚æ•°ä¼ é€’å‡ºå»çš„
    if (token.reason) {
      // å·²å–æ¶ˆç›´æ¥ return
      return
    }

    token.reason = new Cancel(message) // åˆ›å»ºå–æ¶ˆæ“ä½œæ—¶æŠ›å‡ºçš„å¯¹è±¡
    resolvePromise(token.reason) // æ”¹å˜ Promse çŠ¶æ€ä¸ºæˆåŠŸï¼Œ çœ‹ğŸ‘†ğŸ‘†ğŸ‘†
  })
}

CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  // å¦‚æœå·²è¯·æ±‚å–æ¶ˆï¼Œåˆ™æŠ›å‡º
  if (this.reason) {
    throw this.reason
  }
}

// è¿”å›ä¸€ä¸ªå¯¹è±¡ï¼Œè¯¥å¯¹è±¡åŒ…å«ä¸€ä¸ªæ–°çš„ CancelToken å’Œä¸€ä¸ªå‡½æ•°ï¼Œè°ƒç”¨è¯¥å‡½æ•°æ—¶ å–æ¶ˆè¯·æ±‚
CancelToken.source = function source() {
  var cancel
  var token = new CancelToken(function executor(c) {
    cancel = c
  })
  return {
    token: token,
    cancel: cancel,
  }
}

module.exports = CancelToken
```

#### isCancel.js

> ä»…åˆ¤æ–­æ˜¯å¦æ˜¯ Cancel å®ä¾‹å¯¹è±¡

```js
module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__)
}
```

### adapters

> node çš„ http æ¨¡å—å°è£…çš„ ajax å’Œ XMLHttpRequest å°è£…çš„ ajax

å¯å‚è€ƒå°è£…è‡ªå·±çš„ Ajax æ“ä½œ

#### xhr.js

```js
module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    // è¿”å› Promise
    var requestData = config.data
    var requestHeaders = config.headers

    if (utils.isFormData(requestData)) {
      // æ˜¯ FormData æ•°æ®
      delete requestHeaders['Content-Type']
    }

    if (
      (utils.isBlob(requestData) || utils.isFile(requestData)) &&
      requestData.type
    ) {
      // æ˜¯ äºŒè¿›åˆ¶ã€æ–‡ä»¶ æ•°æ®
      delete requestHeaders['Content-Type']
    }

    var request = new XMLHttpRequest() // åˆ›å»º XMLHttpRequest å¯¹è±¡ï¼Œå¯å‚è€ƒ "XMLHttpRequest ç®€å•ä½¿ç”¨" é‡Œä»‹ç»çš„ å°è£… Ajax

    if (config.auth) {
      // Authorization å¤„ç†
      var username = config.auth.username || ''
      var password = config.auth.password
        ? unescape(encodeURIComponent(config.auth.password)) // å¯¹ç‰¹æ®Šå­—ç¬¦è¿›è¡Œè½¬ä¹‰
        : ''
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password) // è½¬æ¢ä¸º base64
    }

    var fullPath = buildFullPath(config.baseURL, config.url) // å®Œæ•´è¯·æ±‚åœ°å€

    // åˆå§‹åŒ–ä¸€ä¸ªè¯·æ±‚
    request.open(
      config.method.toUpperCase(),
      buildURL(fullPath, config.params, config.paramsSerializer), // ä¸€å®šè§„åˆ™æ‹¼æ¥ params åˆ°è·¯å¾„ä¸Šï¼ŒparamsSerializer ç”¨æˆ·è‡ªå®šä¹‰çš„ å‚æ•°åºåˆ—åŒ–å‡½æ•°
      true
    )

    request.timeout = config.timeout // è¶…æ—¶æ—¶é—´

    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return
      }
      // å¦‚æœå‡ºé”™ï¼Œreturn
      if (
        request.status === 0 &&
        !(request.responseURL && request.responseURL.indexOf('file:') === 0)
      ) {
        return
      }
      // å“åº”æ•°æ®
      var responseHeaders =
        'getAllResponseHeaders' in request
          ? parseHeaders(request.getAllResponseHeaders())
          : null
      var responseData =
        !config.responseType || config.responseType === 'text'
          ? request.responseText
          : request.response
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request,
      }

      settle(resolve, reject, response) // éªŒè¯å“åº”çŠ¶æ€ç é»˜è®¤ 200 - 300, æ ¹æ®çŠ¶æ€ç åˆ¤æ–­æ˜¯ resolve è¿˜æ˜¯ rejectã€‚ ç”¨æˆ·å¯è‡ªå®šä¹‰åˆæ³•å€¼éªŒè¯(config.validateStatuså‡½æ•°)

      request = null // æ¸…ç©ºå½“å‰è¯·æ±‚
    }
    // å½“ request è¢«åœæ­¢æ—¶è§¦å‘ï¼ˆæµè§ˆå™¨è¡Œä¸ºï¼Œéæ‰‹åŠ¨å–æ¶ˆè¡Œä¸ºï¼‰
    request.onabort = function handleAbort() {
      if (!request) {
        return
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request))

      request = null
    }

    // å½“ request é­é‡é”™è¯¯æ—¶è§¦å‘
    request.onerror = function handleError() {
      reject(createError('Network Error', config, null, request))

      request = null
    }

    // åœ¨é¢„è®¾æ—¶é—´å†…æ²¡æœ‰æ¥æ”¶åˆ°å“åº”æ—¶è§¦å‘
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded'
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage
      }
      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED', request))

      request = null
    }

    if (utils.isStandardBrowserEnv()) {
      // æ ‡å‡†æµè§ˆå™¨ç¯å¢ƒ
      var xsrfValue =
        (config.withCredentials || isURLSameOrigin(fullPath)) &&
        config.xsrfCookieName
          ? cookies.read(config.xsrfCookieName)
          : undefined

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue
      }
    }

    // request æ·»åŠ  headers
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (
          typeof requestData === 'undefined' &&
          key.toLowerCase() === 'content-type'
        ) {
          // content-type æ˜¯ undefined åˆ é™¤
          delete requestHeaders[key]
        } else {
          request.setRequestHeader(key, val)
        }
      })
    }

    // ç”¨æ¥æŒ‡å®šè·¨åŸŸ Access-Control è¯·æ±‚æ˜¯å¦åº”å½“å¸¦æœ‰æˆæƒä¿¡æ¯ï¼Œå¦‚ cookie æˆ–æˆæƒ header å¤´ã€‚
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials
    }

    // ç»™ request æ·»åŠ  responseType
    if (config.responseType) {
      try {
        request.responseType = config.responseType
      } catch (e) {
        if (config.responseType !== 'json') {
          throw e
        }
      }
    }

    // ä¸‹è½½è¿›åº¦ äº‹ä»¶
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress)
    }

    // ä¸Šä¼ è¿›åº¦ äº‹ä»¶
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress)
    }

    if (config.cancelToken) {
      // å–æ¶ˆè¯·æ±‚
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return
        }

        request.abort() // çœŸå®è°ƒç”¨ request å–æ¶ˆè¯·æ±‚æ“ä½œ
        reject(cancel)
        request = null
      })
    }

    if (!requestData) {
      requestData = null
    }

    // å‘é€è¯·æ±‚
    request.send(requestData)
  })
}
```

#### http.js

```js
module.exports = function httpAdapter(config) {
  return new Promise(function dispatchHttpRequest(
    resolvePromise,
    rejectPromise
  ) {
    var resolve = function resolve(value) {
      resolvePromise(value)
    }
    var reject = function reject(value) {
      rejectPromise(value)
    }
    var data = config.data
    var headers = config.headers

    // è®¾ç½®ç”¨æˆ·ä»£ç†
    if (!headers['User-Agent'] && !headers['user-agent']) {
      headers['User-Agent'] = 'axios/' + pkg.version // axios ç‰ˆæœ¬
    }
    // data æ˜¯å¯¹è±¡æˆ–å‡½æ•°ï¼Œè½¬æ¢ä¸º æµçš„å½¢å¼ä¼ è¾“
    if (data && !utils.isStream(data)) {
      if (Buffer.isBuffer(data)) {
      } else if (utils.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data))
      } else if (utils.isString(data)) {
        data = Buffer.from(data, 'utf-8')
      } else {
        return reject(
          createError(
            'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
            config
          )
        )
      }
      // æ·»åŠ  Content-Length å±æ€§
      headers['Content-Length'] = data.length
    }

    // Httpçš„å®‰å…¨è®¤è¯æœºåˆ¶
    var auth = undefined
    if (config.auth) {
      var username = config.auth.username || ''
      var password = config.auth.password || ''
      auth = username + ':' + password
    }

    // è§£æurl
    var fullPath = buildFullPath(config.baseURL, config.url)
    var parsed = url.parse(fullPath) // å°†ä¸€ä¸ªå®Œæ•´çš„URLåœ°å€ï¼Œåˆ†ä¸ºå¾ˆå¤šéƒ¨åˆ†ï¼Œå¸¸ç”¨çš„æœ‰ï¼šhostã€portã€pathnameã€pathã€query
    var protocol = parsed.protocol || 'http:'

    if (!auth && parsed.auth) {
      var urlAuth = parsed.auth.split(':')
      var urlUsername = urlAuth[0] || ''
      var urlPassword = urlAuth[1] || ''
      auth = urlUsername + ':' + urlPassword
    }

    if (auth) {
      delete headers.Authorization
    }

    var isHttpsRequest = isHttps.test(protocol) // æ˜¯å‘èµ· https è¯·æ±‚
    var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent

    var options = {
      // http.request å‚æ•°
      path: buildURL(
        parsed.path,
        config.params,
        config.paramsSerializer
      ).replace(/^\?/, ''),
      method: config.method.toUpperCase(),
      headers: headers,
      agent: agent,
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth: auth,
    }

    if (config.socketPath) {
      // Unix åŸŸå¥—æ¥å­—
      options.socketPath = config.socketPath
    } else {
      options.hostname = parsed.hostname
      options.port = parsed.port
    }

    var proxy = config.proxy // è®¾ç½®äº†ä»£ç†
    if (!proxy && proxy !== false) {
      // å¦‚æœconfig æ²¡æœ‰è®¾ç½®ä»£ç†ï¼Œä» å½“å‰è¿è¡Œç¯å¢ƒä¸­è·å–ä»£ç†
      var proxyEnv = protocol.slice(0, -1) + '_proxy'
      var proxyUrl =
        process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()] // è¿è¡Œç¯å¢ƒä¸­çš„ä»£ç†åœ°å€
      if (proxyUrl) {
        var parsedProxyUrl = url.parse(proxyUrl)
        var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY
        var shouldProxy = true

        if (noProxyEnv) {
          var noProxy = noProxyEnv.split(',').map(function trim(s) {
            return s.trim()
          })

          shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
            if (!proxyElement) {
              return false
            }
            if (proxyElement === '*') {
              return true
            }
            if (
              proxyElement[0] === '.' &&
              parsed.hostname.substr(
                parsed.hostname.length - proxyElement.length
              ) === proxyElement
            ) {
              return true
            }

            return parsed.hostname === proxyElement
          })
        }

        if (shouldProxy) {
          proxy = {
            host: parsedProxyUrl.hostname,
            port: parsedProxyUrl.port,
          }

          if (parsedProxyUrl.auth) {
            var proxyUrlAuth = parsedProxyUrl.auth.split(':')
            proxy.auth = {
              username: proxyUrlAuth[0],
              password: proxyUrlAuth[1],
            }
          }
        }
      }
    }

    if (proxy) {
      options.hostname = proxy.host
      options.host = proxy.host
      options.headers.host =
        parsed.hostname + (parsed.port ? ':' + parsed.port : '')
      options.port = proxy.port
      options.path =
        protocol +
        '//' +
        parsed.hostname +
        (parsed.port ? ':' + parsed.port : '') +
        options.path

      // ä»£ç†å®‰å…¨è®¤è¯
      if (proxy.auth) {
        var base64 = Buffer.from(
          proxy.auth.username + ':' + proxy.auth.password,
          'utf8'
        ).toString('base64')
        options.headers['Proxy-Authorization'] = 'Basic ' + base64
      }
    }

    var transport // é€šè¿‡åˆ¤æ–­é‡‡ç”¨ä½•ç§ node http(https|follow-redirects) æ¨¡å—
    var isHttpsProxy =
      isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true)
    if (config.transport) {
      transport = config.transport // ä¼˜å…ˆä½¿ç”¨ ç”¨æˆ·é…ç½®çš„ ä¼ è¾“æ¨¡å—
    } else if (config.maxRedirects === 0) {
      transport = isHttpsProxy ? https : http // http(https)
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects
      }
      transport = isHttpsProxy ? httpsFollow : httpFollow // follow-redirects é‡å®šå‘
    }

    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength
    }

    // åˆ›å»ºè¯·æ±‚
    var req = transport.request(options, function handleResponse(res) {
      if (req.aborted) return // è¯·æ±‚å·²å–æ¶ˆ return

      // å‹ç¼©å“åº”ä¸»ä½“
      var stream = res

      // åœ¨é‡å®šå‘çš„æƒ…å†µä¸‹è¿”å›æœ€åä¸€ä¸ªè¯·æ±‚
      var lastRequest = res.req || req

      // å¦‚æœæ²¡æœ‰å†…å®¹ï¼ŒHEADè¯·æ±‚(æˆ–configé…ç½®äº†) ä¸åº”è¯¥è§£å‹
      if (
        res.statusCode !== 204 &&
        lastRequest.method !== 'HEAD' &&
        config.decompress !== false
      ) {
        switch (res.headers['content-encoding']) {
          case 'gzip':
          case 'compress':
          case 'deflate':
            // å°† unzipper æ·»åŠ åˆ° body æµå¤„ç†ç®¡é“
            stream = stream.pipe(zlib.createUnzip()) // å°†æµæ•°æ®è§£å‹ç¼©
            // åˆ é™¤å†…å®¹ç¼–ç 
            delete res.headers['content-encoding']
            break
        }
      }

      var response = {
        // æ„å»ºå“åº”å¯¹è±¡
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: res.headers,
        config: config,
        request: lastRequest,
      }

      if (config.responseType === 'stream') {
        // å¦‚æœè¦æ±‚å“åº”ç±»å‹ä¸º æµï¼Œç›´æ¥è¿”å› æµ
        response.data = stream
        settle(resolve, reject, response) // éªŒè¯å“åº”çŠ¶æ€ç é»˜è®¤ 200 - 300, æ ¹æ®çŠ¶æ€ç åˆ¤æ–­æ˜¯ resolve è¿˜æ˜¯ rejectã€‚ ç”¨æˆ·å¯è‡ªå®šä¹‰åˆæ³•å€¼éªŒè¯(config.validateStatuså‡½æ•°)
      } else {
        var responseBuffer = []
        stream.on('data', function handleStreamData(chunk) {
          responseBuffer.push(chunk)

          // å¦‚æœè®¾ç½®äº† maxContentLengthï¼Œåœ¨ä¸ç¬¦åˆ maxContentLength çš„æƒ…å†µä¸‹ï¼Œè¿”å›å¤±è´¥ç»“æœå¹¶å…³é—­ è¯»å–æµ
          if (
            config.maxContentLength > -1 &&
            Buffer.concat(responseBuffer).length > config.maxContentLength
          ) {
            stream.destroy()
            reject(
              createError(
                'maxContentLength size of ' +
                  config.maxContentLength +
                  ' exceeded',
                config,
                null,
                lastRequest
              )
            )
          }
        })
        // ç”±äºåº•å±‚å†…éƒ¨çš„æ•…éšœè€Œæ— æ³•ç”Ÿæˆæ•°æ®ï¼Œæˆ–è€…æµçš„å®ç°å°è¯•æ¨é€æ— æ•ˆçš„æ•°æ®å—æ—¶è§¦å‘
        stream.on('error', function handleStreamError(err) {
          if (req.aborted) return
          reject(enhanceError(err, config, null, lastRequest))
        })
        // æµ è¯»å–å®Œæ¯•æ—¶è§¦å‘
        stream.on('end', function handleStreamEnd() {
          var responseData = Buffer.concat(responseBuffer) // å°†æ¥æ”¶çš„æ•°æ® åˆå¹¶æˆä¸€ä¸ª buffer
          if (config.responseType !== 'arraybuffer') {
            // é arraybuffer
            responseData = responseData.toString(config.responseEncoding) // è½¬æ¢æˆç”¨æˆ·é…ç½®çš„ responseEncoding(2-36) è¿›åˆ¶
            if (
              !config.responseEncoding ||
              config.responseEncoding === 'utf8'
            ) {
              responseData = utils.stripBOM(responseData)
            }
          }

          response.data = responseData
          settle(resolve, reject, response)
        })
      }
    })

    // è¯·æ±‚é‡åˆ°é—®é¢˜
    req.on('error', function handleRequestError(err) {
      if (req.aborted && err.code !== 'ERR_FR_TOO_MANY_REDIRECTS') return
      reject(enhanceError(err, config, null, req))
    })

    if (config.timeout) {
      // ä¸€æ—¦å°†å¥—æ¥å­—åˆ†é…ç»™æ­¤è¯·æ±‚å¹¶ä¸”è¿æ¥äº†å¥—æ¥å­—ï¼Œå°±ä¼šè°ƒç”¨ socket.setTimeout()
      // config.timeout: è¯·æ±‚è¶…æ—¶å‰çš„æ¯«ç§’æ•°, handleRequestTimeout: å‘ç”Ÿè¶…æ—¶æ—¶è¦è°ƒç”¨çš„å¯é€‰å‡½æ•°ã€‚ç›¸å½“äºç»‘å®šåˆ° 'timeout' äº‹ä»¶
      req.setTimeout(config.timeout, function handleRequestTimeout() {
        req.abort()
        reject(
          createError(
            'timeout of ' + config.timeout + 'ms exceeded',
            config,
            'ECONNABORTED',
            req
          )
        )
      })
    }

    if (config.cancelToken) {
      // å–æ¶ˆå¤„ç†
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (req.aborted) return

        req.abort()
        reject(cancel)
      })
    }

    // å‘é€è¯·æ±‚
    if (utils.isStream(data)) {
      data
        .on('error', function handleStreamError(err) {
          reject(enhanceError(err, config, null, req))
        })
        .pipe(req)
    } else {
      req.end(data)
    }
  })
}
```
